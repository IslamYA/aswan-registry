from __future__ import division  # This makes division behave like Python 3
from part import *
from material import *
from section import *
from assembly import *
from step import *
from interaction import *
from load import *
from mesh import *
from optimization import *
from job import *
from sketch import *
from visualization import *
from connectorBehavior import *

import math
from abaqus import getInputs

# Define input fields with prompts and default values
fields = (
    ("Density (tonne/mm^3):", "7.8e-09"),
    ("Young's modulus E (MPa):", "200000.0"),
    ("Poisson's ratio:", "0.3"),
    ("Yield strength (MPa):", "415.0"),
    ("Ultimate tensile strength (MPa):", "580.0"),
    ("Engineering strain at fracture (elongation):", "0.15"),
    ("Number of interpolation points:", "4"),
    ("Material name:", "steel_rebar"),
)


def eng_to_true_stress(sigma_eng, strain_eng):
    return sigma_eng * (1 + strain_eng)


def eng_to_true_strain(strain_eng):
    return math.log(1 + strain_eng)


def generate_stress_strain(E, sigma_y, sigma_u, frac_strain_eng, n_points):
    points = []

    # Elastic yield point
    points.append((round(sigma_y, 6), round(0.0, 6)))

    # True ultimate stress at fracture strain
    sigma_true_u = eng_to_true_stress(sigma_u, frac_strain_eng)
    eps_true_u = eng_to_true_strain(frac_strain_eng)
    plastic_u = eps_true_u - sigma_true_u / E

    # Interpolate between yield and UTS
    for i in range(1, n_points + 1):
        t = float(i) / float(n_points)  # Explicit float conversion for Python 2.7
        sigma_eng = sigma_y + t * (sigma_u - sigma_y)
        strain_eng = t * frac_strain_eng
        sigma_true = eng_to_true_stress(sigma_eng, strain_eng)
        eps_true = eng_to_true_strain(strain_eng)
        eps_plastic = eps_true - sigma_true / E

        points.append((round(sigma_true, 6), round(eps_plastic, 6)))

    # Ensure last point matches UTS, but avoid duplicate
    last = points[-1]
    sigma_true_u_rounded = round(sigma_true_u, 6)
    plastic_u_rounded = round(plastic_u, 6)

    if (
        abs(last[0] - sigma_true_u_rounded) > 1e-6
        or abs(last[1] - plastic_u_rounded) > 1e-8
    ):
        points.append((sigma_true_u_rounded, plastic_u_rounded))

    return points


# Get user inputs

values = getInputs(
    fields,
    label="Please provide the following information",
    dialogTitle="Rebar Material Parameters",
)

if values[0] is None:
    print("User cancelled input process.")
else:
    # Unpack and convert values to appropriate types
    density = float(values[0])
    E = float(values[1])
    poisson_ratio = float(values[2])
    sigmaY = float(values[3])
    sigmaU = float(values[4])
    fracStrainEng = float(values[5])
    nPoints = int(values[6])
    material_name = values[7]

    curve = generate_stress_strain(E, sigmaY, sigmaU, fracStrainEng, nPoints)

    # Get the first model in the mdb
    model = mdb.models.values()[0]

    # Create material
    model.Material(name=material_name)
    material = model.materials[material_name]

    material.setValues(
        description="Rebar material: yield={} MPa, ultimate={} MPa, E={} MPa, Engineering strain at fracture (elongation): {}.\n\ngenerated by setup_rebar_material script".format(
            sigmaY, sigmaU, E, fracStrainEng
        )
    )

    material.Elastic(
        dependencies=0,
        moduli=LONG_TERM,
        noCompression=OFF,
        noTension=OFF,
        table=((E, poisson_ratio),),
        temperatureDependency=OFF,
        type=ISOTROPIC,
    )

    material.Density(
        dependencies=0,
        distributionType=UNIFORM,
        fieldName="",
        table=((density,),),
        temperatureDependency=OFF,
    )

    material.Plastic(
        dataType=HALF_CYCLE,
        dependencies=0,
        hardening=ISOTROPIC,
        numBackstresses=1,
        rate=OFF,
        strainRangeDependency=OFF,
        table=tuple(curve),
        temperatureDependency=OFF,
    )

    material.setValues(materialIdentifier="")
